---
## Front matter
title: "Отчет о прохождении внешнего курса"
subtitle: "Введение, работа на сервере, продвинутые темы"
author: "Машков Илья Евгеньевич"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Ознакомиться с функционалом операционной системы Linux.

# Задание

Изучить информацию и пройти тестовые задания.

# Выполнение внешнего курса

## 1.Введение

Прочитав название курса, выбрал правильный ответ (рис. @fig:001).

![Задание 1](image/1.png){#fig:001 width=70%}

Прочитав введение в курс, выбрал правильные ответы (рис. @fig:002).

![Задание 2](image/2.png){#fig:002 width=70%}

Указал на каких системах уже рабтал (рис. @fig:003).

![Задание 3](image/3.png){#fig:003 width=70%}

Oracle VM VirtualBox — самое популярное в мире кросс-платформенное ПО для виртуализации с открытым кодом — позволяет разработчикам быстрее поставлять код за счет возможности запускать на одном устройстве несколько операционных систем. (рис. @fig:004).

![Задание 4](image/4.png){#fig:004 width=70%}

Уже запускал систему Linux в Virtual box. Причем пробовал разные дистрибутивы, такие как: Fedora, Kali (рис. @fig:005).

![Задание 5](image/5.png){#fig:005 width=70%}

Я создал документ word, выбрал определенный шрифт, и перед сохранением выбрал нужный формат, а после прикрепил к курсу (рис. @fig:006).

![Задание 6](image/6.png){#fig:006 width=70%}

Deb (сокр. от Debian) — расширение имён файлов «бинарных» пакетов для распространения и установки программного обеспечения в операционной системе проекта Debian и других, использующих систему управления пакетами dpkg (рис. @fig:007).

![Задание 7](image/7.png){#fig:007 width=70%}

У меня уже был установлен VLC media pleer, поэтому просто захожу в About и копирую фамилию разработчика (рис. @fig:008).

![Задание 8](image/8.png){#fig:008 width=70%}

Менеджер обновлений (Update Manager) — это программа для обновления установленного программного обеспечения в дистрибутивах ОС Linux, основанных на Debian или использующих систему управления пакетами APT (рис. @fig:009).

![Задание 9](image/9.png){#fig:009 width=70%}

Консоль(cmd) == Терминал. Ассоль - героиня литературного произведения, а термин - это определение (рис. @fig:010).

![Задание 10](image/10.png){#fig:010 width=70%}

Команда pwd - это очень простая утилита, которая позволяет вывести в терминал путь к текущей папке, причем регистр имеет значение (рис. @fig:011).

![Задание 11](image/11.png){#fig:011 width=70%}

Интерфейс командной строки Linux является регистрозависимым, поэтому, где буква А - строчная нам не подходит (рис. @fig:012).

![Задание 12](image/12.png){#fig:012 width=70%} 

Все возможные способы перехождения в нужную папку:
 1. ls ../Downloads
 2. ls ~/Downloads
 3. ls /home/bi/Downloads

![Задание 13](image/13.png){#fig:013 width=70%}

Чтобы удалить директорию можно использовать rm -r, а также rmdir. Разница между ними в том, что rm -r может удалять ещё и файлы и удаляет файлы находящиеся в папке (рис. @fig:014).

![Задание 14](image/14.png){#fig:014 width=70%}

Проверил в Virtual box (рис. @fig:015).

![Задание 15](image/15.png){#fig:015 width=70%}

& - это запуск в фоновом режиме (рис. @fig:016).

![Задание 16](image/16.png){#fig:016 width=70%}

Проверил в виртуальной машине (рис. @fig:017).

![Задание 17](image/17.png){#fig:017 width=70%}

По умолчанию входной поток связан с клавиатурой, а выходной поток и поток сообщений об ошибках направлены на терминал пользователя. Другими словами, вся выходная информация запущенной пользователем команды или программы, а также все сообщения об ошибках, выводятся в окно терминала, то есть на экран (рис. @fig:018).

![Задание 18](image/18.png){#fig:018 width=70%}

1. < file — использовать файл как источник данных для стандартного потока ввода.

2. > file — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.

3. 2> file — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.

4. >>file — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.

5. 2>>file — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.

6. &>file или >&file — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1.

![Задание 19](image/19.png){#fig:019 width=70%}

cat names.txt | ./interacter.py | less - вывод на экран, если же добавить >err.txt, то тогда будет записывать в файл err.txt (рис. @fig:020).

![Задание 20](image/20.png){#fig:020 width=70%}

При выполнении команды происходят такие действия:
1. Скачивается файл в директорию /home/alex/Pictures
2. Из-за ключа -0 1.jpg, файл конвертируется в 1.jpg и размещается директории, в которой мы находимся, так как путь файла уже не указан, а указано только название - 1.jpg.

![Задание 21](image/21.png){#fig:021 width=70%}

-q
--quiet
   Turn off Wget's output. (рис. @fig:022).

![Задание 22](image/22.png){#fig:022 width=70%}

Опции команды wget:

1. -r, --recursive - Включить рекурсивную загрузку.
2. -l depth, --level=depth - Максимальная глубина рекурсивной загрузки depth. По умолчанию ее значение равно 5.
3. -A logfile --append-output=logfile - Дополнить logfile. Как и -o, только logfile не заменяется, а дополняется. Если logfile не существует, создается новый файл.

![Задание 23](image/23.png){#fig:023 width=70%}

gzip (сокращение от GNU Zip) — утилита сжатия и восстановления (декомпрессии) файлов, использующая алгоритм Deflate (рис. @fig:024).

![Задание 24](image/24.png){#fig:024 width=70%}

tar - архиватор. gzip - компрессор. zip - 2 в 1, архиватор и компрессор (рис. @fig:025).

![Задание 25](image/25.png){#fig:025 width=70%}

Создание выполняется с ключом c. j - Использование bzip2. f - архив в файловой системе (рис. @fig:026).

![Задание 26](image/26.png){#fig:026 width=70%}

`?` - один символ, `alexey` - из-за маленькой буквы. Файл должен быть `jpeg`, а не `jpg` (рис. @fig:027).

![Задание 27](image/27.png){#fig:027 width=70%}

Регистр важен, слово - `world`, а не `word` (рис. @fig:028).

![Задание 28](image/28.png){#fig:028 width=70%}

Решил на виртуальной машине (рис. @fig:029).

![Задание 29 на виртуалке](image/29.png){#fig:029 width=70%}

А затем отправил файл со всеми строками, в которых было слово "love" (рис. @fig:030).

![Задание 29](image/30.png){#fig:030 width=70%}

## Работа на сервере

Удаленный сервер — это программный веб-сервер, к которому можно получить доступ через интернет. Он может принадлежать непосредственно компании и арендоваться у хостинг-провайдера в облаке, на виртуальных мощностях. Другие компьютеры подсоединяются к нему через службы удаленного доступа (RAS) (@fig:031).

![Задание 1](image/31.png){#fig:031 width=70%}

Только id_rsa.pub, поскольку это public key (@fig:032).

![Задание 2](image/32.png){#fig:032 width=70%}

The scp -r command in Linux is used to copy an entire directory and its contents (@fig:033).

![Задание 3](image/33.png){#fig:033 width=70%}

Проверяем интернет соединение, затем проверяем то, об существовании такой программы (@fig:034).

![Задание 4](image/34.png){#fig:034 width=70%}

Filezilla - cвободный многоязычный проект, посвящённый приложениям для FTP.
Проект включает в себя:
- отдельное приложение «FileZilla Client» (являющееся FTP-клиентом);
- «FileZilla Server» (FTP-сервер).
Приложения публикуются с открытым исходным кодом для Windows, macOS и Linux (@fig:035).

![Задание 5](image/35.png){#fig:035 width=70%}

1. Проверить, актуальность версии этой программы, ещё поможет попробовать другую версию программы
2. Настроить сервер, чтобы он поддерживал вывод информации на экран компьютера (@fig:036).

![Задание 6](image/36.png){#fig:0036 width=70%} 

![Задание 7](image/37.png){#fig:037 width=70%}

FastQC supports files in the following formats

FastQ (all quality encoding variants)
Casava FastQ files*
Colorspace FastQ
GZip compressed FastQ
SAM
BAM
SAM/BAM Mapped only (normally used for colorspace data) (@fig:038).

![Задание 8](image/38.png){#fig:038 width=70%}

-align - Do full multiple alignment (@fig:039).

![Задание 9](image/39.png){#fig:039 width=70%}

Комбинация Ctrl+С - завершает процесс, а комбинация Ctrl+Z - приостанавливает процесс (@fig:040).

![Задание 10](image/40.png){#fig:040 width=70%}

![Задание 11](image/41.png){#fig:041 width=70%}

kill — наиболее распространённый способ отправки сигналов процессам. Эта команда принимает два аргумента: номер или имя сигнала и PID процесса, который надо завершить.(@fig:042).

![Задание 12](image/42.png){#fig:042 width=70%}

Команда kill шлёт сигнал о завершении процесса. Но программа обрабатывает сигналы только когда она исполняется, пока она остановлена она не может обработать сигнал и приступит к его обработке только после продолжения работы (@fig:043).

![Задание 13](image/43.png){#fig:043 width=70%}

Приостановленная программа не потребляет ресурсы процессора компьютера (@fig:044).

![Задание 14](image/44.png){#fig:044 width=70%}

Приостановленная программа не потребляет ресурсы процессора компьютера. При этом, в оперативной памяти оно сохранится, поэтому оно будет занимать столько же оперативной памяти, сколько до постановки на паузу (@fig:045).

![Задание 15](image/45.png){#fig:045 width=70%}

Threads are an integral part of the process and cannot be killed outside it. There is the pthread_kill function but it only applies in the context of the thread itself. From the docs at the link:
Note that pthread_kill() only causes the signal to be handled in the context of the given thread; the signal action (termination or stopping) affects the process as a whole (@fig:046).

![Задание 16](image/46.png){#fig:046 width=70%}

![Задание 17](image/47.png){#fig:047 width=70%}

Программа:
``` bash
echo "306174 reads; of these:
  306174 (100.00%) were unpaired; of these:
    11 (0.00%) aligned 0 times
    305580 (99.81%) aligned exactly 1 time
    583 (0.19%) aligned >1 times
100.00% overall alignment rate" > bowtie.log
```

![Задание 18](image/48.png){#fig:048 width=70%}

![Задание 19](image/49.png){#fig:049 width=70%}

exit завершит работу tmux (@fig:050).

![Задание 20](image/50.png){#fig:050 width=70%}

Соединение с сервером прервется, а tmux будет продолжать свою работу на сервере (@fig:051).

![Задание 21](image/51.png){#fig:051 width=70%}

![Задание 22](image/52.png){#fig:052 width=70%}

Ctrl+b c - создать новое окно;

Ctrl+b 0-9 - открыть окно по его номеру;

Ctrl+b , - переименовать текущее окно;

Ctrl+b % - разделить текущую панель по горизонтали;

Ctrl+b " - разделить текущую панель по вертикали;

Ctrl+b стрелка - перейти на панель, находящуюся в стороне, куда указывает стрелка;

Ctrl+b Ctrl+стрелка - изменить размер текущей панели;

Ctrl+b o - перейти на следующую панель;

Ctrl+b ; - переключаться между текущей и предыдущей панелью;

Ctrl+b x - закрыть текущую панель;

Ctrl+b [ - войти в режим копирования (подробнее ниже);

Ctrl+b ] - вставить из внутреннего буфера обмена tmux;

Ctrl+b d - отключится от текущей сессии;

Ctrl+b : - открыть командную строку.

Ctrl+b w - выбрать окно из списка;

![Задание 23](image/53.png){#fig:053 width=70%}

![Задание 24](image/54.png){#fig:054 width=70%}

## Продвинутые темы

Клавиши:
- ZQ - выйти без сохранения
- :q! - выйти без сохранения
- ZZ - записать файл и выйти (если файл не изменяли, то записываться он не будет)
- :wq - записать файл и выйти
- :x - записать файл и выйти
- :w<CR> - записать файл
- :sav filename<CR> - "сохранить как"
- :w filename<CR> - "сохранить как"
- :w!<CR> - записать файл

![Задание 1](image/55.png){#fig:055 width=70%}

`Strange_  TEXT  is_here. 2=2 YES!`

Точка считается "маленьким словом", так что всего их 9:
`Strange_`, `is_here`, `.`, `2`, `=`, `2`, `!` и `два лишних пробела` (@fig:056).

![Задание 2](image/56.png){#fig:056 width=70%} 

- $ — в конец текущей строки;
- w — на слово вправо;
- b — на слово влево;
- i — начать ввод перед курсором;
- p — вставка содержимого неименнованного буфера под курсором;
- P — вставка содержимого неименованного буфера перед курсором;
- yy (также Y) — копирование текущей строки в неименованный буфер;
- y<число>y — копирование числа строк начиная с текущей в неименованный буфер;

![Задание 3](image/57.png){#fig:057 width=70%}

![Задание 4](image/58.png){#fig:058 width=70%}

Команда $ — в конец текущей строки, W - до пробела вправо - то есть, перемещение.

Нажать Esc достаточно один раз, но да ладно.

Надпись visual - горит.

d — используется совместно с командами перемещения. Удаляет символы с текущего положения курсора до положения после ввода команды перемещения.(@fig:059).

yy (также Y) — копирование текущей строки в буфер;

![Задание 5](image/59.png){#fig:059 width=70%}

![Задание 6](image/60.png){#fig:060 width=70%}

`/home/bi/file1.txt` - так как в этой директории мы создаем новый файл, а уже после его создания мы переходим в другую папку (@fig:061).

![Задание 7](image/61.png){#fig:061 width=70%}

1. НЕ МОЖЕТ НАЧИНАТЬСЯ С ЦИФРЫ, но может начинаться с символа;
2. Регистр букв значения не имеет;
3. Точек быть не может.

Все вышеперечисленные пункты относятся к заданию 8 (@fig:062).

![Задание 8](image/62.png){#fig:062 width=70%}

Программа:
 
``` bash
#!/bin/bash
var1=$1
var2=$2
echo "Arguments are: \$1=$var1 \$2=$var2"
```

![Задание 9](image/63.png){#fig:063 width=70%}

- $0 #имя скрипта;
- z <string> # string empty;
- n <string> # string not empty;
- eq, (==)    # равно;
- ne, (!=)    # не равно;
- lt, (<)    # меньше;
- le,         # меньше или равно;
- gt, (>)    # больше;
- ge,         # больше или равно;
- e <path>    # путь существует;
- f <path>    # это файл;
- d <path>    # это директория;
- s <path>    # разм файла больше 0;
- x <path>    # файл исполняемый (@fig:064).        

![Задание 10](image/64.png){#fig:064 width=70%} 

- $0 #имя скрипта;
- z <string> # string empty;
- n <string> # string not empty;
- eq, (==)    # равно;
- ne, (!=)    # не равно;
- lt, (<)    # меньше;
- le,         # меньше или равно;
- gt, (>)    # больше;
- ge,         # больше или равно;
- e <path>    # путь существует;
- f <path>    # это файл;
- d <path>    # это директория;
- s <path>    # разм файла больше 0;
- x <path>    # файл исполняемый (@fig:065).

![Задание 11](image/65.png){#fig:065 width=70%}

Программа: 
``` bash
#!/bin/bash
if [[ $1 -eq 1 ]]; 
then
    echo "$1 student"
elif [[ $1 -gt 1 && $1 -le 4 ]]; 
then
    echo "$1 students"
elif [[ $1 -ge 5 ]]; 
then
    echo "A lot of students"
else
    echo "No students"
fi
```

![Задание 12](image/66.png){#fig:066 width=70%}

![Задание 13](image/67.png){#fig:067 width=70%}

Программа: 
```bash
while [[ 1==1 ]]
do
        group=""
        echo "enter your name:"
        read name
        if [[ -z $name ]]
        then
                break
        fi
        echo "enter your age:"
        read age
        if [[ $age -eq 0 ]]
        then
                break
        fi
        if [[ $age -le 16 ]]
        then
                group="child"
        elif [[ $age -le 25 ]]
        then
                group="youth"
        else
                group="adult"
        fi
        echo "$name, your group is $group"
done
echo "bye"
```

![Задание 14](image/68.png){#fig:068 width=70%}

1) a и $a это одно и то же;

2) a += b это то же самое что и a = a + b, но "+=" != "=+";

3) если выражение НЕ в скобках, с пробелами работать не будет. (let a=a+b - ок; let a = a + b - не ок) (@fig:069).

![Задание 15](image/69.png){#fig:069 width=70%}

Выведет путь до директории, в которую мы перешли, так как "```pwd```" - это команда (@fig:070).

![Задание 16](image/70.png){#fig:070 width=70%}

![Задание 17](image/71.png){#fig:071 width=70%}

Первая переменная локальная равная пустой строке, вторая переменная - это сумма арифметической прогрессии от 1 до 10, равна 55, но при умножении на 2 даст 110 (@fig:072).

![Задание 18](image/72.png){#fig:072 width=70%}

Программа:

``` bash
while [ true ] 
do
    read n1 n2
if [ -z $n1 ]; then
    echo "bye"
    break
else
    gcd () {
    remainder=1
    if [ $n2 -eq 0 ]
    then
    echo "bye"
    fi
    while [ $remainder -ne 0 ]
    do
    remainder=$((n1%n2))
    n1=$n2
    n2=$remainder
    done
    }
    gcd $1 $2
    echo "GCD is $n1" 
fi
done
```

![Задание 19](image/73.png){#fig:073 width=70%}

Программа:
```bash
# put your shell (bash) code here
#!/bin/bash
while [[ True ]]
do
  read birinchi amal ikkinchi
  if [[ $birinchi == "exit" ]]
  then
    echo "bye"
    break
  elif [[ "$birinchi" =~ "^[0-9]+$" && "$ikkinchi" =~ "^[0-9]+$" ]]
  then
    echo "error"
    break
  else
    case $amal in
"+") let "result = birinchi + ikkinchi";;
"-") let "result = birinchi - ikkinchi";;
"/") let "result = birinchi / ikkinchi";;
"*") let "result = birinchi * ikkinchi";;
"%") let "result = birinchi % ikkinchi";;
"**") let "result = birinchi ** ikkinchi";;
*) echo "error" ; break ;;
    esac
    echo "$result"
  fi
done
```

![Задание 20](image/74.png){#fig:074 width=70%}

- iname ищет без учета регистра, а -name в точности как в запросе (@fig:075).

![Задание 21](image/75.png){#fig:075 width=70%}

find - путь; -name - образец
проверяет на соответствие образцу только собственно имя файла.
Bash - Выделить код
1 find - путь; -path - образец
проверяет на соответствие образцу полное имя файла с путём.
То есть, для файла /home/user/test на соответствие образцу будет проверяться:

- для -name -- только "test"
- для -path -- "/home/user/test"

Причём, для -path проверяется строка целиком, без учета деления на каталоги (@fig:076).

![Задание 22](image/76.png){#fig:076 width=70%}



Главное понимать что текущий каталог - это depth=1, а остальное считается просто:

/home/bi   -> depth=1

/home/bi/dir1   -> depth=2

/home/bi/dir1/dir2   -> depth=3 (@fig:077).

![Задание 23](image/77.png){#fig:077 width=70%}

![Задание 24](image/78.png){#fig:078 width=70%}

[xklXKL] - Первые буквы.
[uU]buntu$ - Последние буквы.

![Задание 25](image/79.png){#fig:079 width=70%}

The -n option disables the automatic printing, which means the lines you don't specifically tell it to print do not get printed, and lines you do explicitly tell it to print (e.g. with p) get printed only once (@fig:080).

![Задание 26](image/80.png){#fig:080 width=70%}

аббревиатура ABBA отличается от двух других аббревиатур тем, что справа он неё стоит запятая без пробела: "ABBA,". 

При этом по условию аббревиатура должна выглядеть как [ XX ] или [ XXX ] (и ещё больше X). Следовательно, для этой проверки надо добавить пробел квадратными скобками [ ] слева и, соответственно, с права (@fig:081).

![Задание 27](image/81.png){#fig:081 width=70%}

-persist lets plot windows survive after main gnuplot program exits (@fig:082).

![Задание 28](image/82.png){#fig:082 width=70%}

`plot 'data.csv' using 1:2` даст ошибку:

`warning: Skipping data file with no valid points ^ x range is invalid`

Скорее всего причиной такого поведения является тот факт, что формат CSV содержит строки, где столбцы разделены запятой? Содержимое файла:

```
1,21
2,22
3,23
4,24
5,25
6,26
7,27
8,28
9,29
10,30
```

![Задание 29](image/83.png){#fig:083 width=70%}

Сначала идет команда установки подписей, а потом в скобках ПОДПИСЬ пробел ПЕРЕМЕННАЯ С КООРДИНАТОЙ запятая повторяется это количество раз соответствующее числу переменных, и без запятой в случае с последней переменной), а ПОДПИСЬ в свою очередь получается конкатенацией ТЕКСТА ИЗ ЗАДАНИЯ и ПЕРЕМЕННОЙ С КООРДИНАТОЙ, например конкатенируем имя IVAN и переменную Y (@fig:084):
"IVAN".Y

![Задание 30](image/84.png){#fig:084 width=70%}


Программа (@fig:085):
```
a=a+1
zrot=(zrot+350)%360
set view xrot,zrot
splot -x**2-y**2
pause 0.1
if (a<50) reread
```

![Задание 31](image/85.png){#fig:085 width=70%}

![Задание 32](image/86.png){#fig:086 width=70%}

- r - чтение;
- w - запись;
- x - выполнение;
- s - выполнение  от имени суперпользователя (дополнительный);
- u - владелец файла;
- g - группа файла;
- o - все остальные пользователи;
- 0 - никаких прав;
- 1 - только выполнение;
- 2 - только запись;
- 3 - выполнение и запись;
- 4 -  только чтение;
- 5 - чтение и выполнение;
- 6 - чтение и запись;
- 7 - чтение запись и выполнение (@fig:087).

![Задание 33](image/87.png){#fig:087 width=70%} 

- wc -l <filename> вывести количество строк;
- wc -c <filename> вывести количество байт;
- wc -m <filename> вывести количество символов;
- wc -L <filename> вывести длину самой длинной строки;
- wc -w <filename> вывести количество слов (@fig:088).

![Задание 34](image/88.png){#fig:088 width=70%}

- a, --all - выводить размер для всех файлов, а не только для директорий, по умолчанию размер выводится только для папок;
- B, --block-size - указать единицы вывода размера, доступно: K,M,G,T,P,E,Z,Y для 1024 и KB, MB и так далее для 1000;
- c, --total - выводить в конце общий размер всех папок;
- d, --max-depth - максимальная глубина вложенности директорий;
- h, --human-readable - выводить размер в единицах измерения удобных для человека;
- --inodes - выводить информацию об использованию inode;
- L, --dereference - следовать по всем символическим ссылкам;
- l, --count-links - учитывать размер файла несколько раз для жестких ссылок;
- P, --no-dereference - не следовать по символическим ссылкам, это поведение используется по умолчанию;
- S, --separate-dirs - не включать размер подпапок в размер папки;
- -si - выводить размер файлов и папок в системе си, используется 1000 вместо 1024;
- s, --summarize - выводить только общий размер;
- t, --threshold - не учитывать файлы и папки с размером меньше указанного;
- --time - отображать время последней модификации для файла или папки, вместо времени модификации можно выводить такие метки: atime, access, use, ctime;
- X, --exclude - исключить файлы из подсчёта;
- x, --one-file-system - пропускать примонтированные файловые системы;
- --version - вывести версию утилиты (@fig:089).

![Задание 35](image/89.png){#fig:089 width=70%}

Команда создает три директории от dir1 до dir3 (@fig:090).

![Задание 36](image/90.png){#fig:090 width=70%}

# Вывод

При выполнении внешнего курса я освежил в памяти первые этапы ознакомления с Linux (установка линукса на виртуальную машину, основы работы с терминалом, запуск исполняеемых файлов, скачивание файлов и поисковые операции), повторил основы работы с сервером и приобрёл навыки работы с bash-программированием.

В подверждении прохождения данного курса прикрепляю свой сертификат (@fig:091):

![Сертификат.](image/91.png){#fig:091 width=70%}

# Список литературы{.unnumbered}

1. [Внешний курс](https://stepik.org/course/73/syllabus)

2. [Сертификат](https://stepik.org/cert/2468445)

